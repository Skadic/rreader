/* automatically generated by rust-bindgen 0.59.2 */

use std::{ffi::CString, path::Path};

use crate::{error::RePairError, coding::navarro_repair_decoder::RePairResult};

const TWO: ::std::os::raw::c_int = 2;

extern "C" {
    fn run_repair(argc: ::std::os::raw::c_int, argv: *const *const ::std::os::raw::c_char);
}


pub fn repair(file: impl AsRef<str>) -> Result<RePairResult, RePairError> {
    let file = file.as_ref();
    // Try to open the file. We do this to quit with an error if the file doesn't exist
    std::fs::File::open(Path::new(file))?;

    let file_c_str = CString::new(file.trim())?;
    // The binary path is unneeded for repair, so we can just pass an empty string.
    let binary_path = CString::new("")?;

    let argv = [binary_path.as_ptr(), file_c_str.as_ptr()];

    unsafe { run_repair(TWO, argv.as_ptr()) }

    let file_c_name = format!("{file}.C");
    let file_r_name = format!("{file}.R");
    
    let file_c = std::fs::read(&file_c_name)?;
    let file_r = std::fs::read(&file_r_name)?;

    std::fs::remove_file(file_c_name)?;
    std::fs::remove_file(file_r_name)?;

    Ok(RePairResult { file_c, file_r })
}
